#version 450 core

//#define INDIRECT_SHADOW

#include "globalubos.glsl"
#include "utils.glsl"
#define LIGHTCACHEMODE LIGHTCACHEMODE_LIGHT
#include "lightcache.glsl"

layout(binding=0) uniform sampler2D RSM_Flux;
layout(binding=1) uniform sampler2D RSM_DepthLinSq;
layout(binding=2) uniform isampler2D RSM_Normal;

layout(binding=4) uniform sampler3D VoxelVolume;

struct LightInfo
{
	vec3 Flux;
	float DiscArea;
	vec3 Position;
	vec3 Normal;
};
shared LightInfo RSMCache[LIGHTING_THREADS_PER_GROUP];


// Morton helper - http://and-what-happened.blogspot.de/2011/08/fast-2d-and-3d-hilbert-curves-and.html
// unpack 2 16-bit indices from a 32-bit Morton code
uvec2 Morton_2D_Decode_16bit(in uint morton)
{
	uvec2 coord;
	coord.x = morton;
	coord.y = ( coord.x >> 1 );
	coord &= 0x55555555;
	coord |= ( coord >> 1 );
	coord &= 0x33333333;
	coord |= ( coord >> 2 );
	coord &= 0x0f0f0f0f;
	coord |= ( coord >> 4 );
	coord &= 0x00ff00ff;
	coord |= ( coord >> 8 );
	coord &= 0x0000ffff;
	
	return coord;
}


layout (local_size_x = LIGHTING_THREADS_PER_GROUP, local_size_y = 1, local_size_z = 1) in;
void main()
{
	vec3 worldPosition = LightCacheEntries[gl_GlobalInvocationID.x].Position;
	vec3 toCamera = normalize(CameraPosition - worldPosition);
	mat3 cacheLocalViewSpace = ComputeLocalViewSpace(worldPosition);

#ifdef INDIRECT_SHADOW
	ivec3 volumeSize = textureSize(VoxelVolume, 0);
	vec3 voxelPos = (worldPosition - VolumeWorldMin) / (VoxelSizeInWorld * volumeSize);
	float startOffset = sqrt(2.0) * AddressVolumeVoxelSize / VoxelSizeInWorld + 0.5;
#endif

	// TODO: Use UBO for these.
	const float shCosLobeFactor00 = sqrt(PI) / 2.0;
	const float shCosLobeFactor1n1 = -sqrt(PI / 3.0); 	// * toVal.y;
	const float shCosLobeFactor10 = sqrt(PI / 3.0); 	// * toVal.z;
	const float shCosLobeFactor1p1 = -sqrt(PI / 3.0); 	// * toVal.x;
	const float shCosLobeFactor2n2 = sqrt(15.0 * PI) / 8.0 ; //* toVal.x * toVal.y;
	const float shCosLobeFactor2n1 = -sqrt(15.0 * PI) / 8.0; // * toVal.y * toVal.z;
	const float shCosLobeFactor20 = sqrt(5.0 * PI) / 16.0; 	// * (toVal.z * toVal.z * 3.0 - 1.0);
	const float shCosLobeFactor2p1 = -sqrt(15.0 * PI) / 8.0; // * toVal.x * toVal.z;
	const float shCosLobeFactor2p2 = sqrt(15.0 * PI) / 16.0; // * (toVal.x*toVal.x - toVal.y*toVal.y);


#if defined(INDDIFFUSE_VIA_SH1) || defined(INDDIFFUSE_VIA_SH2)
	vec3 SH00 = vec3(0);
	vec3 SH1neg1 = vec3(0);
	vec3 SH10 = vec3(0);
	vec3 SH1pos1 = vec3(0);
	#ifdef INDDIFFUSE_VIA_SH2
	vec3 SH2neg2 = vec3(0);
	vec3 SH2neg1 = vec3(0);
	vec3 SH20 = vec3(0);
	vec3 SH2pos1 = vec3(0);
	vec3 SH2pos2  = vec3(0);
	#endif
#endif

	/*vec3 spec_SH00 = vec3(0);
	vec3 spec_SH1neg1 = vec3(0);
	vec3 spec_SH10 = vec3(0);
	vec3 spec_SH1pos1 = vec3(0);

	vec3 spec_SH2neg2 = vec3(0);
	vec3 spec_SH2neg1 = vec3(0);
	vec3 spec_SH20 = vec3(0);
	vec3 spec_SH2pos1 = vec3(0);
	vec3 spec_SH2pos2  = vec3(0);*/

#ifdef INDDIFFUSE_VIA_H
	vec3 irradianceHBasis[INDDIFFUSE_VIA_H];
	for(int i=0; i<INDDIFFUSE_VIA_H; ++i)
		irradianceHBasis[i] = vec3(0);
#endif


	float distThreshholdSq = dot(AddressVolumeVoxelSize, AddressVolumeVoxelSize);

	int totalNumRSMPixels = ShadowMapResolution * ShadowMapResolution;
	for(uint rsmPixelIndex = 0; rsmPixelIndex < totalNumRSMPixels; rsmPixelIndex += LIGHTING_THREADS_PER_GROUP)
	{
		// Load LIGHTING_THREADS_PER_GROUP RMS pixels
		LightInfo cacheEntry;

		// Unpack rsmPixelIndex to a actual position.
		uint localRsmPixelPos = rsmPixelIndex + gl_LocalInvocationID.x;
		ivec2 rsmSamplePos = ivec2(Morton_2D_Decode_16bit(localRsmPixelPos)); 
		//ivec2 rsmSamplePos = ivec2(localRsmPixelPos / ShadowMapResolution, localRsmPixelPos % ShadowMapResolution);
		vec2 rsmSamplePosF = (rsmSamplePos + vec2(0.5)) / ShadowMapResolution;

		// Sample flux
		cacheEntry.Flux = textureLod(RSM_Flux, rsmSamplePosF, 0).rgb;

		// Sample Depth and compute VAL area
		float sourceLightToVAL = textureLod(RSM_DepthLinSq, rsmSamplePosF, 0).r;
		cacheEntry.DiscArea = sourceLightToVAL * sourceLightToVAL * ValAreaFactor; // Estimate size of virtual area light

		// Compute world position.
		vec4 rsmClipSpace = vec4(rsmSamplePosF * 2.0 - vec2(1.0), 0.0, 1.0) * InverseLightViewProjection;
		cacheEntry.Position = LightPosition + normalize(rsmClipSpace.xyz / rsmClipSpace.w - LightPosition) * sourceLightToVAL;

		// Sample and unpack Normal
		cacheEntry.Normal = UnpackNormal16I(textureLod(RSM_Normal, rsmSamplePosF, 0).xy);

		// Write into cache, all together.
		barrier(); // Wait for other threads to chew their lights
 		RSMCache[gl_LocalInvocationID.x] = cacheEntry;
		barrier(); // Make sure all other threads have written their lights.

		// Shadow value changes only every SHADOW_COMPUTATION_INTERVAL_BLOCK samples.
		float shadowing = 1.0;

		for(int i=0; i<LIGHTING_THREADS_PER_GROUP; ++i)
		{
		#ifdef INDIRECT_SHADOW
			if(i % IndirectShadowComputationSampleInterval == 0)
			{
				uint localRsmPixelPos = uint(rsmPixelIndex + i);
				uvec2 upperLeftSampleTexel = Morton_2D_Decode_16bit(localRsmPixelPos);
				vec2 rsmMidTexcoord = (upperLeftSampleTexel + IndirectShadowSamplingOffset) / ShadowMapResolution;

				vec2 d_dsq = textureLod(RSM_DepthLinSq, rsmMidTexcoord, IndirectShadowComputationLod).xy;
				vec4 rsmClipSpace = vec4(rsmMidTexcoord * 2.0 - vec2(1.0), 0.0, 1.0) * InverseLightViewProjection;
				vec3 averageValPos = LightPosition + normalize(rsmClipSpace.xyz / rsmClipSpace.w - LightPosition) * d_dsq.x;

				// Compute angle needed for this sample.
				// For this we estimate the sphere containing most samples:
				float averageDepthSq = d_dsq.x * d_dsq.x;
				float depthVariance = d_dsq.y - d_dsq.x * d_dsq.x;
				
				// halfConeAngle = asin(sampleSphereRadius / d_dsq.x)
				// For cone tracing we need a conversion of dist to sphere: radius = dist * sin(halfConeAngle)
				// -> distToSphereRad = sin(halfConeAngle) = sampleSphereRadius / d_dsq.x

				//float sampleSphereRadius = max(d_dsq.x * IndirectShadowComputationSuperValWidth, // Estimate super-val width
				//								sqrt(depthVariance) * 2.0); // Assuming normation distribuation of samples in depth -  Depth deviation * 2.0 -> 95% of all samples

				//float distToSphereRad = sampleSphereRadius / d_dsq.x;
				// Simplification yields:
				float distToSphereRad = max(IndirectShadowComputationSuperValWidth, sqrt(depthVariance) * 2.0 / d_dsq.x);
				distToSphereRad = max(distToSphereRad, IndirectShadowSamplingMinDistToSphereFactor); // Clamp to small values.


				vec3 toAverageVal = averageValPos - worldPosition;
				float lightDist = length(toAverageVal);
				toAverageVal /= lightDist;
				vec3 dirInVoxel = toAverageVal / volumeSize;

				vec3 currentPosVoxel = voxelPos + dirInVoxel*startOffset;
				//float lastOcclusion = 0.0;
				float occlusion = 0.0;
				float stepSize = 1.0;
				float dist = 0.0;
				float goalDist = lightDist / VoxelSizeInWorld - startOffset;// Assuming that the light is within the voxel bounds!

				for(int s=0; s<64; ++s)
				{
					currentPosVoxel += dirInVoxel * stepSize;
					//if(saturate(currentPosVoxel) != currentPosVoxel) break; // seems not to be necessary

					dist += stepSize;

					float currentSphereRadius = dist * distToSphereRad;

					// Lookup in miplevel that has voxels of the size of the current sphere radius.
					float newOcclusion = textureLod(VoxelVolume, currentPosVoxel, log2(currentSphereRadius)).r; 
					//lastOcclusion = occlusion;
					occlusion += (1.0 - occlusion) * newOcclusion;

					if(dist >= goalDist)
						break;

					stepSize = currentSphereRadius * 2.0;
				}

				//occlusion = mix(lastOcclusion, occlusion, (dist - goalDist) / stepSize); // should be correcter but yields more artefacts.
				shadowing = saturate(1.0 - occlusion);
			}
		#endif

			{
				vec3 valPosition = RSMCache[i].Position;

				// Direction and distance to light.
				vec3 toVal = valPosition.xyz - worldPosition;
				//if(dot(toVpl, worldNormal) > 0) // Early out if facing away from the light. 
				//	continue;
				float lightDistanceSq = dot(toVal, toVal);
				toVal *= inversesqrt(lightDistanceSq);

				// Light intensity
				vec3 valTotalExitantFlux = RSMCache[i].Flux;
				vec3 valNormal = RSMCache[i].Normal;
				float fluxToIntensity = saturate(dot(valNormal, -toVal)) / PI;

				fluxToIntensity *= shadowing;

				// Ignore too close light sources due to 
				//if(lightDistanceSq < distThreshholdSq)
				//	fluxToIntensity = 0; // continue; // Continue, even is placed as early as possible, is slower.

				vec3 scaledIntensity = valTotalExitantFlux * (fluxToIntensity / (lightDistanceSq + RSMCache[i].DiscArea));
				//vec3 scaledIntensity = valTotalExitantFlux * (fluxToIntensity / lightDistanceSq); // VPL instead of VAL


			#if defined(INDDIFFUSE_VIA_SH1) || defined(INDDIFFUSE_VIA_SH2)
				// SH Irradiance
				SH00 += shCosLobeFactor00 * scaledIntensity;
				SH1neg1 += (shCosLobeFactor1n1 * toVal.y) * scaledIntensity;
				SH10 += (shCosLobeFactor10 * toVal.z) * scaledIntensity;
				SH1pos1 += (shCosLobeFactor1p1 * toVal.x) * scaledIntensity;

				#ifdef INDDIFFUSE_VIA_SH2
					SH2neg2 += (shCosLobeFactor2n2 * toVal.x * toVal.y) * scaledIntensity;
					SH2neg1 += (shCosLobeFactor2n1 * toVal.y * toVal.z) * scaledIntensity;
					SH20 += (shCosLobeFactor20 * (toVal.z * toVal.z * 3.0 - 1.0)) * scaledIntensity;
					SH2pos1 += (shCosLobeFactor2p1 * toVal.x * toVal.z) * scaledIntensity;
					SH2pos2 += (shCosLobeFactor2p2 * (toVal.x * toVal.x - toVal.y * toVal.y)) * scaledIntensity;
				#endif
			#endif


			#ifdef INDDIFFUSE_VIA_H
				// H-Basis Irradiance
				toVal = toVal * cacheLocalViewSpace;

				float SH00 = shCosLobeFactor00;
				float SH1neg1 = shCosLobeFactor1n1  * toVal.y;
				float SH10 = shCosLobeFactor10  * toVal.z;
				float SH1pos1 = shCosLobeFactor1p1 * toVal.x;
				float SH2neg2 = shCosLobeFactor2n2 * toVal.x * toVal.y;
				float SH2neg1 = shCosLobeFactor2n1 * toVal.y * toVal.z;
				float SH20 = shCosLobeFactor20 * (toVal.z * toVal.z * 3.0 - 1.0);
				float SH2pos1 = shCosLobeFactor2p1  * toVal.x * toVal.z;
				float SH2pos2 = shCosLobeFactor2p2  * (toVal.x*toVal.x - toVal.y*toVal.y);

				irradianceHBasis[0] += (1.0 / sqrt(2) * SH00 		+ 0.5 * sqrt(3.0/2.0) * SH10) * scaledIntensity; 
				irradianceHBasis[1] += (1.0 / sqrt(2) * SH1neg1 	+ 3.0 / 8.0 * sqrt(5.0/2.0) * SH2neg1) * scaledIntensity; 
				irradianceHBasis[2] += (1.0 / (2.0*sqrt(2)) * SH10 	+ 1.0 / 4.0 * sqrt(15.0/2.0) * SH20) * scaledIntensity; 
				irradianceHBasis[3] += (1.0 / sqrt(2) * SH1pos1 	+ 3.0 / 8.0 * sqrt(5.0/2.0) * SH2pos1) * scaledIntensity;
				#if INDDIFFUSE_VIA_H > 4
				irradianceHBasis[4] += (1.0 / sqrt(2) * SH2neg2) * scaledIntensity; 
				irradianceHBasis[5] += (1.0 / sqrt(2) * SH2pos2) * scaledIntensity; 
				#endif
			#endif

				// Specular
				/*vec3 halfVector = normalize(toCamera + toVal);

				const float specFactor0 = sqrt(PI);
				const float specFactor1 = sqrt(3*PI);
				spec_SH00 += specFactor0 * scaledIntensity;
				spec_SH1neg1 -= (specFactor1 * halfVector.y) * scaledIntensity;
				spec_SH10 += (specFactor1 * halfVector.z) * scaledIntensity;
				spec_SH1pos1 -= (specFactor1 * halfVector.x) * scaledIntensity;

				const float specFactor2 = sqrt(15.0 * PI) / 2.0;
				const float specFactor3 = sqrt(5.0 * PI) / 4.0;
				spec_SH2neg2 += (specFactor2 * halfVector.x * halfVector.y) * scaledIntensity;
				spec_SH2neg1 -= (specFactor2 * halfVector.y * halfVector.z) * scaledIntensity;
				spec_SH20 += (specFactor3 * (halfVector.z * halfVector.z * 3.0 - 1.0)) * scaledIntensity;
				spec_SH2pos1 -= (specFactor2 * halfVector.x * halfVector.z) * scaledIntensity;
				spec_SH2pos2 += (specFactor2 * (halfVector.x * halfVector.x - halfVector.y * halfVector.y)) * scaledIntensity;*/
			}
		}
	}

	
	if(gl_GlobalInvocationID.x < TotalLightCacheCount)
	{
		// Save to buffer.
	#ifdef INDDIFFUSE_VIA_H
		LightCacheEntries[gl_GlobalInvocationID.x].irradianceH1 = irradianceHBasis[0];
		LightCacheEntries[gl_GlobalInvocationID.x].irradianceH4r = irradianceHBasis[3].r;
		LightCacheEntries[gl_GlobalInvocationID.x].irradianceH2 = irradianceHBasis[1];
		LightCacheEntries[gl_GlobalInvocationID.x].irradianceH4g = irradianceHBasis[3].g;
		LightCacheEntries[gl_GlobalInvocationID.x].irradianceH3 = irradianceHBasis[2];
		LightCacheEntries[gl_GlobalInvocationID.x].irradianceH4b = irradianceHBasis[3].b;
		#if INDDIFFUSE_VIA_H > 4
		LightCacheEntries[gl_GlobalInvocationID.x].irradianceH5 = irradianceHBasis[4];
		LightCacheEntries[gl_GlobalInvocationID.x].irradianceH6 = irradianceHBasis[5];
		#endif
	#endif

	#if defined(INDDIFFUSE_VIA_SH1) || defined(INDDIFFUSE_VIA_SH2)
		LightCacheEntries[gl_GlobalInvocationID.x].SH1neg1 = SH1neg1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_r = SH00.r;
		LightCacheEntries[gl_GlobalInvocationID.x].SH10 = SH10;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_g = SH00.g;
		LightCacheEntries[gl_GlobalInvocationID.x].SH1pos1 = SH1pos1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_b = SH00.b;

		#ifdef INDDIFFUSE_VIA_SH2
		LightCacheEntries[gl_GlobalInvocationID.x].SH2neg2 = SH2neg2;
		LightCacheEntries[gl_GlobalInvocationID.x].SH20_r = SH20.r;
		LightCacheEntries[gl_GlobalInvocationID.x].SH2neg1 = SH2neg1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH20_g = SH20.g;
		LightCacheEntries[gl_GlobalInvocationID.x].SH2pos1 = SH2pos1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH20_b = SH20.b;
		LightCacheEntries[gl_GlobalInvocationID.x].SH2pos2 = SH2pos2;
		#endif
	#endif

		/*LightCacheEntries[gl_GlobalInvocationID.x].spec_SH1neg1 = spec_SH1neg1;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH00_r = spec_SH00.r;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH10 = spec_SH10;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH00_g = spec_SH00.g;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH1pos1 = spec_SH1pos1;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH00_b = spec_SH00.b;

		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH2neg2 = spec_SH2neg2;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH20_r = spec_SH20.r;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH2neg1 = spec_SH2neg1;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH20_g = spec_SH20.g;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH2pos1 = spec_SH2pos1;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH20_b = spec_SH20.b;
		LightCacheEntries[gl_GlobalInvocationID.x].spec_SH2pos2 = spec_SH2pos2;*/
	}
}