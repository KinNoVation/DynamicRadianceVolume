#version 450 core

//#define INDIRECT_SHADOW

#include "globalubos.glsl"
#include "utils.glsl"
#define LIGHTCACHEMODE LIGHTCACHEMODE_LIGHT
#include "lightcache.glsl"

layout(binding=0) uniform sampler2D RSM_Flux;
layout(binding=1) uniform sampler2D RSM_DepthLinSq;
layout(binding=2) uniform isampler2D RSM_Normal;
layout(binding=3) uniform sampler3D VoxelVolume;

struct LightInfo
{
	vec3 Flux;
	float DiscArea;
	vec3 Position;
	vec3 Normal;
};
shared LightInfo RSMCache[LIGHTING_THREADS_PER_GROUP];


// Morton helper - http://and-what-happened.blogspot.de/2011/08/fast-2d-and-3d-hilbert-curves-and.html
// unpack 2 16-bit indices from a 32-bit Morton code
uvec2 Morton_2D_Decode_16bit(in uint morton)
{
	uvec2 coord;
	coord.x = morton;
	coord.y = ( coord.x >> 1 );
	coord &= 0x55555555;
	coord |= ( coord >> 1 );
	coord &= 0x33333333;
	coord |= ( coord >> 2 );
	coord &= 0x0f0f0f0f;
	coord |= ( coord >> 4 );
	coord &= 0x00ff00ff;
	coord |= ( coord >> 8 );
	coord &= 0x0000ffff;
	
	return coord;
}


layout (local_size_x = LIGHTING_THREADS_PER_GROUP, local_size_y = 1, local_size_z = 1) in;
void main()
{
	vec3 worldPosition = LightCacheEntries[gl_GlobalInvocationID.x].Position;

#ifdef INDIRECT_SHADOW
	ivec3 volumeSize = textureSize(VoxelVolume, 0);
	vec3 voxelPos = (worldPosition - VolumeWorldMin) / (VoxelSizeInWorld * volumeSize);
	float startOffset = sqrt(2.0) * AddressVolumeVoxelSize / VoxelSizeInWorld + 1.0;
#endif


	vec3 SH00 = vec3(0);
	vec3 SH1neg1 = vec3(0);
	vec3 SH10 = vec3(0);
	vec3 SH1pos1 = vec3(0);

	float distThreshholdSq = dot(AddressVolumeVoxelSize, AddressVolumeVoxelSize);

	int totalNumRSMPixels = ShadowMapResolution * ShadowMapResolution;
	for(uint rsmPixelIndex = 0; rsmPixelIndex < totalNumRSMPixels; rsmPixelIndex += LIGHTING_THREADS_PER_GROUP)
	{
		// Load LIGHTING_THREADS_PER_GROUP RMS pixels
		LightInfo cacheEntry;

		// Unpack rsmPixelIndex to a actual position.
		uint localRsmPixelPos = rsmPixelIndex + gl_LocalInvocationID.x;
		ivec2 rsmSamplePos = ivec2(Morton_2D_Decode_16bit(localRsmPixelPos)); 
		//ivec2 rsmSamplePos = ivec2(localRsmPixelPos / ShadowMapResolution, localRsmPixelPos % ShadowMapResolution);
		vec2 rsmSamplePosF = (rsmSamplePos + vec2(0.5)) / ShadowMapResolution;

		// Sample flux
		cacheEntry.Flux = textureLod(RSM_Flux, rsmSamplePosF, 0).rgb;

		// Sample Depth and compute VAL area
		float sourceLightToVAL = textureLod(RSM_DepthLinSq, rsmSamplePosF, 0).r;
		cacheEntry.DiscArea = sourceLightToVAL * sourceLightToVAL * ValAreaFactor; // Estimate size of virtual area light

		// Compute world position.
		vec4 rsmClipSpace = vec4(rsmSamplePosF * 2.0 - vec2(1.0), 0.0, 1.0) * InverseLightViewProjection;
		cacheEntry.Position = LightPosition + normalize(rsmClipSpace.xyz / rsmClipSpace.w - LightPosition) * sourceLightToVAL;

		// Sample and unpack Normal
		cacheEntry.Normal = UnpackNormal16I(textureLod(RSM_Normal, rsmSamplePosF, 0).xy);

		// Write into cache, all together.
		barrier(); // Wait for other threads to chew their lights
 		RSMCache[gl_LocalInvocationID.x] = cacheEntry;
		barrier(); // Make sure all other threads have written their lights.


		#define SHADOW_COMPUTATION_LOD 2
		#define SHADOW_COMPUTATION_INTERVAL_BLOCK (1<<SHADOW_COMPUTATION_LOD)
		#define SHADOW_COMPUTATION_INTERVAL (SHADOW_COMPUTATION_INTERVAL_BLOCK * SHADOW_COMPUTATION_INTERVAL_BLOCK)
		const vec2 shadowRSMSamplingOffset = vec2(0.5 + sqrt(2.0) * SHADOW_COMPUTATION_INTERVAL_BLOCK / 2.0);

		#if LIGHTING_THREADS_PER_GROUP % SHADOW_COMPUTATION_INTERVAL != 0
			#error "LIGHTING_THREADS_PER_GROUP needs to be a multiple of SHADOW_COMPUTATION_INTERVAL!"
		#endif

		// Shadow value changes only every SHADOW_COMPUTATION_INTERVAL_BLOCK samples.
		float shadowing = 1.0;

		for(int i=0; i<LIGHTING_THREADS_PER_GROUP; ++i)
		{
		#ifdef INDIRECT_SHADOW
			if(i % SHADOW_COMPUTATION_INTERVAL == 0)
			{
				uint localRsmPixelPos = uint(rsmPixelIndex + i);
				uvec2 upperLeftSampleTexel = Morton_2D_Decode_16bit(localRsmPixelPos);
				vec2 rsmMidTexcoord = (upperLeftSampleTexel + shadowRSMSamplingOffset) / ShadowMapResolution;

				vec2 d_dsq = textureLod(RSM_DepthLinSq, rsmMidTexcoord, SHADOW_COMPUTATION_LOD).xy;
				vec4 rsmClipSpace = vec4(rsmMidTexcoord * 2.0 - vec2(1.0), 0.0, 1.0) * InverseLightViewProjection;
				vec3 averageValPos = LightPosition + normalize(rsmClipSpace.xyz / rsmClipSpace.w - LightPosition) * d_dsq.x;

				// Compute angle needed for this sample.
				// For this we estimate the sphere containing most samples:
				float averageDepthSq = d_dsq.x * d_dsq.x;
				float depthVariance = d_dsq.y - d_dsq.x * d_dsq.x;
				float sampleSphereRadius = max(d_dsq.x * sqrt(ValAreaFactor / PI) * SHADOW_COMPUTATION_INTERVAL_BLOCK, // Estimate super-val width
												sqrt(depthVariance) * 2.0); // Assuming normation distribuation of samples in depth -  Depth deviation * 2.0 -> 95% of all samples

				// halfConeAngle = asin(sampleSphereRadius / d_dsq.x)
				// For cone tracing we need a conversion of dist to sphere: radius = dist * sin(halfConeAngle)
				// -> distToSphereRad = sin(halfConeAngle) = sampleSphereRadius / d_dsq.x

				float distToSphereRad = sampleSphereRadius / d_dsq.x;
				distToSphereRad = max(distToSphereRad, 0.05); // Clamp to small values.


				vec3 toAverageVal = averageValPos - worldPosition;
				float lightDist = length(toAverageVal);
				toAverageVal /= lightDist;
				vec3 dirInVoxel = toAverageVal / volumeSize;

				vec3 currentPosVoxel = voxelPos + dirInVoxel*startOffset;
				//float lastOcclusion = 0.0;
				float occlusion = 0.0;
				float stepSize = 1.0;
				float dist = 0.0;
				float goalDist = lightDist / VoxelSizeInWorld - startOffset;// Assuming that the light is within the voxel bounds!

				for(int s=0; s<32; ++s)
				{
					currentPosVoxel += dirInVoxel * stepSize;
					//if(saturate(currentPosVoxel) != currentPosVoxel) break; // seems not to be necessary

					dist += stepSize;

					float currentSphereRadius = dist * distToSphereRad;

					// Lookup in miplevel that has voxels of the size of the current sphere radius.
					float newOcclusion = textureLod(VoxelVolume, currentPosVoxel, log2(currentSphereRadius)).r; 
					//lastOcclusion = occlusion;
					occlusion += (1.0 - occlusion) * newOcclusion;

					if(dist >= goalDist)
						break;

					stepSize = currentSphereRadius * 2.0;
				}

				//occlusion = mix(lastOcclusion, occlusion, (dist - goalDist) / stepSize); // should be correcter but yields more artefacts.
				shadowing = saturate(1.0 - occlusion);
			}
		#endif

			{
				vec3 valPosition = RSMCache[i].Position;

				// Direction and distance to light.
				vec3 toVal = valPosition.xyz - worldPosition;
				//if(dot(toVpl, worldNormal) > 0) // Early out if facing away from the light. 
				//	continue;
				float lightDistanceSq = dot(toVal, toVal);
				toVal *= inversesqrt(lightDistanceSq);

				// Light intensity
				vec3 valTotalExitantFlux = RSMCache[i].Flux;
				vec3 valNormal = RSMCache[i].Normal;
				float fluxToIntensity = saturate(dot(valNormal, -toVal)) / PI;

				fluxToIntensity *= shadowing;

				// Ignore too close light sources due to 
				//if(lightDistanceSq < distThreshholdSq)
				//	fluxToIntensity = 0; // continue; // Continue, even is placed as early as possible, is slower.

				vec3 scaledIntensity = valTotalExitantFlux * (fluxToIntensity / (lightDistanceSq + RSMCache[i].DiscArea));
				//vec3 scaledIntensity = valTotalExitantFlux * (fluxToIntensity / lightDistanceSq); // VPL instead of VAL


				const float factor0 = sqrt(PI) / 2.0;
				const float factor1 = sqrt(PI / 3.0);

				// Analytical clamped cosine lobe transformation into SH basis
				// Derivation: Assume light direction = z-axis, then rotate resulting zonal harmonics


				SH00 += factor0 * scaledIntensity;
				SH1neg1 -= (factor1 * toVal.y) * scaledIntensity;
				SH10 += (factor1 * toVal.z) * scaledIntensity;
				SH1pos1 -= (factor1 * toVal.x) * scaledIntensity;

				// TODO: Don't know the rotation of the second zonal harmonic
				// cosine lobe second band zonal is sqrt(5*PI)/8 according to https://d3cw3dd2w32x2b.cloudfront.net/wp-content/uploads/2011/06/10-14.pdf
				/*vec3 SH2neg2 = 
				vec3 SH2neg1 = 
				vec3 SH20 = 
				vec3 SH2pos1 = 
				vec3 SH2pos2 =*/
			}
		}
	}

	
	if(gl_GlobalInvocationID.x < TotalLightCacheCount)
	{
		// Save to buffer.
		LightCacheEntries[gl_GlobalInvocationID.x].SH1neg1 = SH1neg1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_r = SH00.r;
		LightCacheEntries[gl_GlobalInvocationID.x].SH10 = SH10;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_g = SH00.g;
		LightCacheEntries[gl_GlobalInvocationID.x].SH1pos1 = SH1pos1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_b = SH00.b;
	}
}