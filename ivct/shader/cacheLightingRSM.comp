#version 450 core

#include "globalubos.glsl"
#include "utils.glsl"
#define LIGHTCACHEMODE LIGHTCACHEMODE_LIGHT
#include "lightcache.glsl"

layout(binding=0) uniform sampler2D RSM_Flux;
layout(binding=1) uniform sampler2D RSM_Depth;
layout(binding=2) uniform isampler2D RSM_Normal;

struct LightInfo
{
	vec3 Flux;
	vec3 Position;
	vec3 Normal;
};
shared LightInfo RSMCache[LIGHTING_THREADS_PER_GROUP];


layout (local_size_x = LIGHTING_THREADS_PER_GROUP, local_size_y = 1, local_size_z = 1) in;
void main()
{
	vec3 worldPosition = LightCacheEntries[gl_GlobalInvocationID.x].Position;

	vec3 SH00 = vec3(0);
	vec3 SH1neg1 = vec3(0);
	vec3 SH10 = vec3(0);
	vec3 SH1pos1 = vec3(0);

	// Analytical clamped cosine lobe transformation into SH basis
	// Derivation: Assume light direction = z-axis, then rotate resulting zonal harmonics


	float distThreshholdSq = dot(AddressVolumeVoxelSize, AddressVolumeVoxelSize);

	int localIndex = int(gl_LocalInvocationID.x);

	int totalNumRSMPixels = ShadowMapResolution * ShadowMapResolution;
	for(int rsmPixelPos = 0; rsmPixelPos < totalNumRSMPixels; rsmPixelPos += LIGHTING_THREADS_PER_GROUP)
	{
		// Load LIGHTING_THREADS_PER_GROUP RMS pixels
		LightInfo cacheEntry;

		int localRsmPixelPos = rsmPixelPos + localIndex;
		ivec2 rsmSamplePos = ivec2(localRsmPixelPos / ShadowMapResolution, localRsmPixelPos % ShadowMapResolution);
		vec2 rsmSamplePosF = (rsmSamplePos + vec2(0.5)) / ShadowMapResolution;

		cacheEntry.Flux = textureLod(RSM_Flux, rsmSamplePosF, 0).rgb;

		float lightDepth = textureLod(RSM_Depth, rsmSamplePosF, 0).r;
		vec4 valPositionCS = vec4(rsmSamplePosF * 2.0 - vec2(1.0), lightDepth, 1.0) * InverseLightViewProjection;
		cacheEntry.Position = valPositionCS.xyz / valPositionCS.w;
		
		cacheEntry.Normal = UnpackNormal16I(textureLod(RSM_Normal, rsmSamplePosF, 0).xy);

		// Write into cache.
		barrier();
 		RSMCache[localIndex] = cacheEntry;
		barrier();

		for(int i=0; i<LIGHTING_THREADS_PER_GROUP; ++i)
		{
			vec3 valPosition = RSMCache[i].Position;

			// Direction and distance to light.
			vec3 toVal = valPosition.xyz - worldPosition;
			//if(dot(toVpl, worldNormal) > 0) // Early out if facing away from the light. 
			//	continue;
			float lightDistanceSq = dot(toVal, toVal);
			toVal *= inversesqrt(lightDistanceSq);

			// Light intensity
			vec3 valTotalExitantFlux = RSMCache[i].Flux;
			vec3 valNormal = RSMCache[i].Normal;

			// Handle light as disc with area. This can be computed analytically for the diffuse term.
			vec3 valToLight = valPosition.xyz - LightPosition;
			float valToLightDistSq = dot(valToLight, valToLight); // todo: Compute directly from lightDepth
			float valArea = valToLightDistSq * ValAreaFactor;
			float fluxToIntensity = saturate(dot(valNormal, -toVal)) / PI;

			// Ignore too close light sources due to 
			if(lightDistanceSq < distThreshholdSq)
				fluxToIntensity = 0; // continue; // Continue, even is placed as early as possible, is slower.


			vec3 scaledIntensity = valTotalExitantFlux * (fluxToIntensity / (lightDistanceSq + valArea));
			//vec3 scaledIntensity = valTotalExitantFlux * (fluxToIntensity / lightDistanceSq); // VPL instead of VAL



			const float factor0 = sqrt(PI) / 2.0;
			const float factor1 = sqrt(PI / 3.0);

			SH00 += factor0 * scaledIntensity;
			SH1neg1 += (factor1 * toVal.y) * scaledIntensity;
			SH10 += (factor1 * toVal.z) * scaledIntensity;
			SH1pos1 += (factor1 * toVal.x) * scaledIntensity;

			// TODO: Don't know the rotation of the second zonal harmonic
			// cosine lobe second band zonal is sqrt(5*PI)/8 according to https://d3cw3dd2w32x2b.cloudfront.net/wp-content/uploads/2011/06/10-14.pdf
			/*vec3 SH2neg2 = 
			vec3 SH2neg1 = 
			vec3 SH20 = 
			vec3 SH2pos1 = 
			vec3 SH2pos2 =*/
		}
	}
		

	if(gl_GlobalInvocationID.x < TotalLightCacheCount)
	{
		// Save to buffer.
		LightCacheEntries[gl_GlobalInvocationID.x].SH1neg1 = SH1neg1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_r = SH00.r;
		LightCacheEntries[gl_GlobalInvocationID.x].SH10 = SH10;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_g = SH00.g;
		LightCacheEntries[gl_GlobalInvocationID.x].SH1pos1 = SH1pos1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_b = SH00.b;
	}
}