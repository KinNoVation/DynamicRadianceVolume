#version 450 core

#define INDIRECT_SHADOW

#include "globalubos.glsl"
#include "utils.glsl"
#define LIGHTCACHEMODE LIGHTCACHEMODE_LIGHT
#include "lightcache.glsl"

layout(binding=0) uniform sampler2D RSM_Flux;
layout(binding=1) uniform sampler2D RSM_Depth;
layout(binding=2) uniform isampler2D RSM_Normal;
layout(binding=3) uniform sampler3D VoxelVolume;

struct LightInfo
{
	vec3 Flux;
	vec3 Position;
	vec3 Normal;
};
shared LightInfo RSMCache[LIGHTING_THREADS_PER_GROUP];


layout (local_size_x = LIGHTING_THREADS_PER_GROUP, local_size_y = 1, local_size_z = 1) in;
void main()
{
	vec3 worldPosition = LightCacheEntries[gl_GlobalInvocationID.x].Position;

#ifdef INDIRECT_SHADOW
	ivec3 volumeSize = textureSize(VoxelVolume, 0);
	vec3 voxelPos = (worldPosition - VolumeWorldMin) / (VoxelSizeInWorld * volumeSize);
	float startOffset = sqrt(2.0) * AddressVolumeVoxelSize / VoxelSizeInWorld + 1.0;
#endif


	vec3 SH00 = vec3(0);
	vec3 SH1neg1 = vec3(0);
	vec3 SH10 = vec3(0);
	vec3 SH1pos1 = vec3(0);

	float distThreshholdSq = dot(AddressVolumeVoxelSize, AddressVolumeVoxelSize);
	int localIndex = int(gl_LocalInvocationID.x);

	int totalNumRSMPixels = ShadowMapResolution * ShadowMapResolution;
	for(int rsmPixelPos = 0; rsmPixelPos < totalNumRSMPixels; rsmPixelPos += LIGHTING_THREADS_PER_GROUP)
	{
		// Load LIGHTING_THREADS_PER_GROUP RMS pixels
		LightInfo cacheEntry;

		int localRsmPixelPos = rsmPixelPos + localIndex;
		ivec2 rsmSamplePos = ivec2(localRsmPixelPos / ShadowMapResolution, localRsmPixelPos % ShadowMapResolution);
		vec2 rsmSamplePosF = (rsmSamplePos + vec2(0.5)) / ShadowMapResolution;

		cacheEntry.Flux = textureLod(RSM_Flux, rsmSamplePosF, 0).rgb;

		float lightDepth = textureLod(RSM_Depth, rsmSamplePosF, 0).r;
		vec4 valPositionCS = vec4(rsmSamplePosF * 2.0 - vec2(1.0), lightDepth, 1.0) * InverseLightViewProjection;
		cacheEntry.Position = valPositionCS.xyz / valPositionCS.w;
		
		cacheEntry.Normal = UnpackNormal16I(textureLod(RSM_Normal, rsmSamplePosF, 0).xy);

		// Write into cache.
		barrier();
 		RSMCache[localIndex] = cacheEntry;
		barrier();

		for(int i=0; i<LIGHTING_THREADS_PER_GROUP; ++i)
		{
			vec3 valPosition = RSMCache[i].Position;

			// Direction and distance to light.
			vec3 toVal = valPosition.xyz - worldPosition;
			//if(dot(toVpl, worldNormal) > 0) // Early out if facing away from the light. 
			//	continue;
			float lightDistanceSq = dot(toVal, toVal);
			float lightDistance = sqrt(lightDistanceSq);
			toVal /= lightDistance; //*= inversesqrt(lightDistanceSq);

			// Light intensity
			vec3 valTotalExitantFlux = RSMCache[i].Flux;
			vec3 valNormal = RSMCache[i].Normal;

			// Handle light as disc with area. This can be computed analytically for the diffuse term.
			vec3 valToLight = valPosition.xyz - LightPosition;
			float valToLightDistSq = dot(valToLight, valToLight); // todo: Compute directly from lightDepth
			float valArea = valToLightDistSq * ValAreaFactor;
			float fluxToIntensity = saturate(dot(valNormal, -toVal)) / PI;

			// Ignore too close light sources due to 
			//if(lightDistanceSq < distThreshholdSq)
			//	fluxToIntensity = 0; // continue; // Continue, even is placed as early as possible, is slower.


			vec3 scaledIntensity = valTotalExitantFlux * (fluxToIntensity / (lightDistanceSq + valArea));
			//vec3 scaledIntensity = valTotalExitantFlux * (fluxToIntensity / lightDistanceSq); // VPL instead of VAL


#ifdef INDIRECT_SHADOW
			if(scaledIntensity.x + scaledIntensity.y + scaledIntensity.z > 0.0000001)
			//if(false)
			{
				vec3 dirInVoxel = toVal / volumeSize;
				vec3 startPositionVoxel = voxelPos + dirInVoxel*startOffset;

				float maxDist = lightDistance / VoxelSizeInWorld;// - startOffset; // Assuming that the light is within the voxel bounds!

				vec3 currentPosVoxel = startPositionVoxel;
				float occlusion = 0.0;
				float stepSize = 1.0;
				float dist = 0.0;

				//float angleBetweenSamples = 1.107148717;
				const float distToSphereRad = 0.1; //0.525731112; //sin(angleBetweenSamples * 0.5);

				for(int s=0; s<64 && dist < maxDist; ++s)
				{
					currentPosVoxel += dirInVoxel * stepSize;
					//sif(saturate(currentPosVoxel) != currentPosVoxel) break;

					dist += stepSize;

					float currentSphereRadius = dist * distToSphereRad;

					// Lookup in miplevel that has voxels of the size of the current sphere radius.
					float newOcclusion = textureLod(VoxelVolume, currentPosVoxel, log2(currentSphereRadius)).r; 
					occlusion += (1.0 - occlusion) * newOcclusion;


					stepSize = currentSphereRadius * 2.0;
				}

				scaledIntensity *= saturate(1.0 - occlusion);
			}
#endif

			const float factor0 = sqrt(PI) / 2.0;
			const float factor1 = sqrt(PI / 3.0);

			// Analytical clamped cosine lobe transformation into SH basis
			// Derivation: Assume light direction = z-axis, then rotate resulting zonal harmonics


			SH00 += factor0 * scaledIntensity;
			SH1neg1 -= (factor1 * toVal.y) * scaledIntensity;
			SH10 += (factor1 * toVal.z) * scaledIntensity;
			SH1pos1 -= (factor1 * toVal.x) * scaledIntensity;

			// TODO: Don't know the rotation of the second zonal harmonic
			// cosine lobe second band zonal is sqrt(5*PI)/8 according to https://d3cw3dd2w32x2b.cloudfront.net/wp-content/uploads/2011/06/10-14.pdf
			/*vec3 SH2neg2 = 
			vec3 SH2neg1 = 
			vec3 SH20 = 
			vec3 SH2pos1 = 
			vec3 SH2pos2 =*/
		}
	}

	
	if(gl_GlobalInvocationID.x < TotalLightCacheCount)
	{
		// Save to buffer.
		LightCacheEntries[gl_GlobalInvocationID.x].SH1neg1 = SH1neg1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_r = SH00.r;
		LightCacheEntries[gl_GlobalInvocationID.x].SH10 = SH10;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_g = SH00.g;
		LightCacheEntries[gl_GlobalInvocationID.x].SH1pos1 = SH1pos1;
		LightCacheEntries[gl_GlobalInvocationID.x].SH00_b = SH00.b;
	}
}